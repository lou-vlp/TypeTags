#pragma once

#include <iostream>
#include <vector>
#include <unordered_map>
#include <bit>
#include <any>
#include <cmath>
#include <memory>
#include <cstring>
#include <cassert>
#include <string>

// Explicitly provide interpolation behavior for things we care to interpolate
template <typename T>
struct Interpolant;

// Constrain operations to things that are interpolatable
template<typename T>
concept Interpolatable = requires(const T & a, const T & b, float t)
{
    { Interpolant<T>::Lerp(a, b, t) } -> std::convertible_to<T>;
};


// Type-indexed type descriptor
struct TypeInfo
{
    static const TypeInfo Invalid;
    size_t tag;
    size_t size;

    friend constexpr auto operator<=>(TypeInfo, TypeInfo) = default;
};
const TypeInfo TypeInfo::Invalid = { static_cast<size_t>(-1), 0 };

// Autogenerated C++ type to TypeInfo mapping
template<Interpolatable T>
class TypeDescriptor
{
public:
    inline static TypeInfo Info;
};

// Keeps track of supported types.
class TypeMap
{
public:
    template <Interpolatable T>
    static TypeInfo Get()
    {
        const auto& info = TypeDescriptor<T>::Info;
        if (!Types.contains(typeid(T).hash_code()))
        {
            throw std::runtime_error("undefined type");
        }
        return info;
    }

private:
    template <Interpolatable... Types>
    friend class InitGlobalTypeIndices;

    template <Interpolatable T>
    static TypeInfo Fresh()
    {
        TypeInfo& info = TypeDescriptor<T>::Info;
        auto hash = typeid(T).hash_code();
        if (!Types.contains(hash))
        {
            info.tag = Count++;
            info.size = sizeof(T);
            Types[hash] = info;
        }
        return info;
    }

    inline static int Count = 0;
    inline static std::unordered_map<size_t, TypeInfo> Types;
};

// Type registration.  Used to generate type GUIDs.
template <Interpolatable... Types>
class InitGlobalTypeIndices
{
public:
    InitGlobalTypeIndices()
    {
        Add();
    }

    static constexpr size_t Count() { return sizeof...(Types); }
    using TypeList = std::tuple<Types...>;

private:
    template <size_t N = 0>
    void Add()
    {
        if constexpr (N < Count())
        {
            using Type = typename std::tuple_element<N, TypeList>::type;
            TypeDescriptor<Type>::Info = TypeMap::Fresh<Type>();
            Add<N + 1>();
        }
    }
};

// Interpolatable parameters
class Parameter
{
public:
    Parameter() noexcept : info(TypeInfo::Invalid)
    {
    }

    Parameter(Parameter&& other) noexcept : info(other.info), value(std::move(other.value))
    {
    }

    Parameter(const Parameter& other)
        : info(other.info)
        , value(other.value)
    {
    }

    Parameter& operator=(const Parameter& other)
    {
        if (this != &other)
        {
            info = other.info;
            value = other.value;
        }
        return *this;
    }

    Parameter& operator=(Parameter&& other) noexcept
    {
        if (this != &other)
        {
            info = other.info;
            value = std::move(other.value);
        }
        return *this;
    }

    template<Interpolatable T>
    explicit Parameter(T x);

    ~Parameter()
    {
        value.reset();
    }

    template <Interpolatable T>
    const T Get() const noexcept;

    template <Interpolatable T>
    T& Get();

    static Parameter Lerp(const Parameter& a, const Parameter& b, float t);
    size_t TypeTag() const noexcept { return info.tag; }
    size_t Size() const noexcept { return info.size; }

private:
    TypeInfo info;
    std::any value;
};

#include "Interpolation.h"

struct ParameterHelpers
{
public:
    static Parameter Lerp(const Parameter& a, const Parameter& b, float t)
    {
        assert(a.TypeTag() == b.TypeTag());
        return Apply(a, b, t, a.TypeTag());
    }

    static std::string Print(const Parameter& param)
    {
        return Print<0>(param);
    }

private:
    template <size_t N = 0>
    static Parameter Apply(const Parameter& a, const Parameter& b, float t, size_t typeTag)
    {
        if constexpr (N < KeyframableTypes.Count())
        {
            using Type = typename std::tuple_element<N, decltype(KeyframableTypes)::TypeList>::type;
            const auto info = TypeMap::Get<Type>();

            if (info.tag == typeTag)
            {
                const auto val = Interpolant<Type>::Lerp(a.Get<Type>(), b.Get<Type>(), t);
                return Parameter(val);
            }
            return Apply<N + 1>(a, b, t, typeTag);
        }

        throw std::runtime_error("Type not found");
    }

    template <size_t N>
    static std::string Print(const Parameter& param)
    {
        if constexpr (N < KeyframableTypes.Count())
        {
            using Type = typename std::tuple_element<N, decltype(KeyframableTypes)::TypeList>::type;
            if (TypeMap::Get<Type>().tag == param.TypeTag())
            {
                return std::to_string(param.Get<Type>());
            }
            return Print<N + 1>(param);
        }

        throw std::runtime_error("Type not found");
    }
};

template<Interpolatable T>
Parameter::Parameter(T x) : info(TypeMap::Get<T>())
{
    value = x;
}

template <Interpolatable T>
const T Parameter::Get() const noexcept
{
    assert(info == TypeDescriptor<T>::Info);
    return std::any_cast<T>(value);
}

template <Interpolatable T>
T& Parameter::Get()
{
    if (info != TypeDescriptor<T>::Info)
    {
        throw std::invalid_argument("type mismatch");
    }
    return std::any_cast<T>(value);
}

Parameter Parameter::Lerp(const Parameter& a, const Parameter& b, float t)
{
    if (a.info.tag != b.info.tag)
    {
        throw std::invalid_argument("type mismatch");
    }
    return ParameterHelpers::Lerp(a, b, t);
}
